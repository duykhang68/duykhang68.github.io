<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Understanding top command</title>
    <meta name="description" content="top is a monitoring program which is used frequently for tracking process‚Äôs resource usage and its activity in real-time, show current tasks being serviced b...">

    <!-- todo: include this into main.css -->

    <link rel="stylesheet" href=" /css/main.css ">
    <link rel="canonical" href="https://llnx.me/technical/2017/07/16/Understanding-top-command.html">
    <link rel="alternate" type="application/rss+xml" title="Hieu's blog" href="https://llnx.me /feed.xml ">
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <script async src="https://llnx.me/assets/dist/fetch.min.js"></script>
    <script>
    (function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
    })(document, window, 'https://analytics.llnx.me/tracker.js', 'fathom');
    fathom('trackPageview');
    </script>
</head>

  <body>
    <div class="page-content">
      <div class="container">
        <div class="three columns">
          <header class="site-header">

  <h1 class="logo"><a href="https://llnx.me/archive">Blog</a></h2>

  <div class="nav">
    
    <label for="menu-toggle" class="menu-icon">
        <!--div data-icon="ei-navicon"></div-->
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
    </label>
    <input type="checkbox" id="menu-toggle">

    <div class="site-nav">
      <nav>
        <ul class="page-link">
          <li><a href="/">Home</a></li>
          <li><a href="/archive">Posts</a></li>
          <li><a href="/about">About</a></li>
          <li><a href="/photography">Photo</a></li>
          <li><a href="/friends">Friends</a></li>
          <li><a href="/hireme" style="color: #C25;font-size: 15px">Hire me ‚ùØ‚ùØ</a></span></li>
          <li><a href="/wtf" style="color: #FFD700;font-size: 15px">WTF‚ùØ‚ùØ</a></span></li>
        </ul>
      </nav>
    </div>

  </div>
</header>

        </div>

        <div class="nine columns" style="z-index:100;">
          <div class="wrapper">
            <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="article_header">
    <h1 class="special_title" itemprop="name headline">Understanding top command</h1>
    <time class="post_date">16 July 2017, Sunday - 11 min read</time>
  </header>

  <div class="article-content" itemprop="articleBody">
    <p><strong><a href="#understanding-top-command"><code class="highlighter-rouge">top</code></a></strong> is a monitoring program which is used frequently for tracking process‚Äôs resource usage and its activity in <strong>real-time</strong>, show current tasks being serviced by the kernel, help <strong>discovering</strong> and <strong>diagnosing</strong> overload or capacity of system by seeing <strong>CPU &amp; Mem usage</strong>. It‚Äôs available under many Unix/Linux operating systems.</p>

<p>Keyword: <a href="/technical/2017/07/16/Understanding-top-command.html#understanding-top-command">top</a>, 
         <a href="/technical/2017/07/16/Understanding-top-command.html#1-date-and-uptime">uptime</a>, 
         <a href="/technical/2017/07/16/Understanding-top-command.html#2-number-of-logged-users">users</a>, 
         <a href="/technical/2017/07/16/Understanding-top-command.html#3-load-average">load average</a>,
         <a href="/technical/2017/07/16/Understanding-top-command.html#4-processthread-state">process/thread state</a>,
         <a href="/technical/2017/07/16/Understanding-top-command.html#5-cpu-organization-and-operation">CPU operation</a></p>

<p><img src="/assets/img/top-command-optimized.gif" alt="" /></p>

<!--description-->

<h2 id="description-from-man-page">Description from man page:</h2>
<p>The top program provides a dynamic real-time view of a running system. It can display system summary information as well as a list of processes or threads currently being managed by the Linux kernel. The types of system summary information shown and the types order and size of information displayed for processes are all user configurable and that configuration can be  made persistent across restarts.</p>

<p>The program provides a limited interactive interface for process manipulation as well as a much more extensive interface for personal configuration - encompassing every aspect of its operation. And while top is referred to throughout this document, you are free to name the program anything you wish. That new name, possibly an alias, will then be reflected on top‚Äôs display and used when reading and writing a configuration file. ‚Ä¶</p>

<p><strong>‚ùØ‚ùØ Need more?</strong> See <a href="http://man7.org/linux/man-pages/man1/top.1.html">http://man7.org/linux/man-pages/man1/top.1.html</a></p>

<p>But it‚Äôs too fucking long üí¢ and want to see the whole picture? üåü Sure, I have a picture below</p>

<h2 id="understanding-top-command">Understanding top command</h2>

<p><img src="/assets/img/top-command.webp" alt="large-img" title="Top command explaination" /></p>

<h3 id="1-date-and-uptime">1. Date and uptime</h3>
<p>Current time is <strong>13:41</strong>, and system has been running for over <strong>5 weeks</strong>, from last boot on <strong>May 17</strong></p>
<div class="highlighter-rouge"><pre class="highlight"><code>top - 13:41:31 up 38 days, 21:04,  3 users,  load average: 0.01, 0.09, 0.13
‚ùØ‚ùØ date
Sun Jun 25 13:41:31 UTC 2017
‚ùØ‚ùØ uptime
13:41:31 up 38 days, 21:04,  3 users,  load average: 0.01, 0.09, 0.13
‚ùØ‚ùØ uptime -p
up 5 weeks, 3 days, 21 hours, 6 minutes
‚ùØ‚ùØ uptime -s
2017-05-17 16:37:26
</code></pre>
</div>

<h3 id="2-number-of-logged-users">2. Number of logged users</h3>
<p>I have 3 logged users and what they are doing:</p>
<ul>
  <li>one is running ssh to other</li>
  <li>one is on bash shell</li>
  <li>and ‚Ä¶ me with <code class="highlighter-rouge">w</code> command</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>3 users
‚ùØ‚ùØ w
 13:41:31 up 38 days, 21:04,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
ubuntu   pts/0    x.205.x.xxx      13:09    1:34   0.07s  0.03s ssh abc.xyz
ubuntu   pts/3    x.64.xx.xxx      05:11    8:36m  0.05s  0.01s -bash
ubuntu   pts/6    x.161.x.xxx      13:47    3.00s  0.04s  0.00s w
</code></pre>
</div>

<h3 id="3-load-average">3. Load average</h3>
<p>The <strong><code class="highlighter-rouge">load average</code></strong> is a number corresponding to the average number of <strong>runnable processes</strong> on the system. The load average is often listed as three sets of numbers, which represent the load average for the past 1, 5, and 15 minutes. - from <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/4/html/Introduction_To_System_Administration/s2-bandwidth-rhlspec-cpu.html">RedHat</a></p>

<p>On Linux systems, these numbers include <strong>processes wanting to run on CPU</strong>, as well as processes blocked in uninterruptible I/O (usually disk I/O). This gives a high level idea of <strong>resource load</strong> (or demand). The three numbers give us some idea of <strong>how load is changing over time</strong>. For example, if you‚Äôve been asked to check a problem server, and the 1 minute value is much lower than the 15 minute value, then you might have logged in too late and missed the issue - from <a href="https://medium.com/netflix-techblog/linux-performance-analysis-in-60-000-milliseconds-accc10403c55">Netfilx Techblog</a></p>

<p><strong><code class="highlighter-rouge">Runable processes</code></strong> means: running and blocked processes (usually by I/O). That‚Äôs really important because it means that you can have <code class="highlighter-rouge">0% CPU usage</code> and still have <code class="highlighter-rouge">high load</code>. The processes blocked on I/O show up in the ‚Äú<strong>D</strong>‚Äù state in <code class="highlighter-rouge">ps</code>, header ‚ÄúSTAT‚Äù or ‚ÄúS‚Äù</p>

<p>Lower numbers are better than higher numbers. If the third number is <strong>too high</strong> (15 minutes ago), I think we got a problem about the performance to deal with. But what‚Äôs the <strong><code class="highlighter-rouge">Threshold</code></strong>, what‚Äôs too high. We need a reasonable and <strong>acceptable value</strong> for comparison.</p>

<h4 id="31-single-logical-cpu">3.1 Single logical CPU</h4>
<p><strong>In general</strong>, with <code class="highlighter-rouge">one logical CPU</code> - 1 vCPU, <strong><code class="highlighter-rouge">Threshold = 0.7</code></strong> is a best practice, many sysadmins will draw a line at 0.70.</p>

<p>For example in case of 1 vCPU:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>load average: 1.25, 0.60, 4.20
</code></pre>
</div>
<ul>
  <li>over the last 1 minute: System was overloaded by <code class="highlighter-rouge">25% on average</code>. 0.25 processes were waiting for the CPU</li>
  <li>over the last 5 minutes: CPU <code class="highlighter-rouge">idled for 40%</code> of the time. <strong>It‚Äôs acceptable</strong></li>
  <li>over the last 15 minutes: System was <code class="highlighter-rouge">overloaded by 320%</code> on average. 3.20 processes were waiting for the CPU.</li>
</ul>

<h4 id="32--multi-logical-cpus">3.2  Multi-logical CPUs</h4>
<p>With 4 logical CPUs system? It‚Äôs still healthy with a load of 2.80 - 3.00. On multi-logical CPUs system, the load is relative to the number of vCPUs available.</p>

<p>The ‚Äú100% utilization‚Äù mark is 1.00 on a single-logical CPU system, 2.00, on a dual vCPUs, 4.00 on a quad-vCPUs, etc.</p>

<p>In <code class="highlighter-rouge">top</code> command, press <code class="highlighter-rouge">1</code> for each vCPU is displayed seperately, also to know number of vCPU.
I have 4 vCPUs in this case, using EC2 AWS C4 type, low load average</p>
<div class="highlighter-rouge"><pre class="highlight"><code>top - 09:10:00 up 32 days, 6 min,  2 users,  load average: 0.01, 0.04, 0.05
Tasks: 125 total,   1 running, 124 sleeping,   0 stopped,   0 zombie
%Cpu0  :  0.7 us,  0.0 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu3  :  5.0 us,  0.3 sy,  0.0 ni, 94.6 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
</code></pre>
</div>

<p>Something more:</p>
<ul>
  <li>üí¢ <strong>Confusing</strong> about vCPUs/cores/threads - See <a href="https://github.com/hieuhtr/Blog/issues/55">CPU Architecture fundamental</a></li>
  <li>üåü For <strong>deep understanding</strong> about load average - See <a href="http://blog.scoutapp.com/articles/2009/07/31/understanding-load-averages">this post</a></li>
  <li>üåü For another example - See <a href="https://en.wikipedia.org/wiki/Load_%28computing%29#Unix-style_load_calculation">wiki</a></li>
  <li>üåü Case: High load average but low CPU ultilization - See <a href="https://www.pitt-pladdy.com/blog/_20150829-125708_0100_Linux_performance_metric_myths_Load_Average_IO_Wait_/">this post</a></li>
</ul>

<h3 id="4-processthread-state">4. Process/Thread state</h3>
<p>Let‚Äôs focus on <strong>Area1</strong> in that <a href="/technical/2017/07/16/Understanding-top-command.html#understanding-top-command">overview picture</a> above. In that top area, <code class="highlighter-rouge">top</code> shows the total number of processes and how many of them are running. But it says <strong>Tasks</strong> not <strong>Processes</strong>. Because another name for a process is a task. The Linux kernel internally refers to processes as tasks.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>Tasks: 283 total,   1 running, 282 sleeping,   0 stopped,   0 zombie
</code></pre>
</div>
<p>From the time a process is born to when it is terminated, the process proceeds through various states. Those states can include <strong>Runnable</strong>, <strong>Running</strong>, <strong>Sleeping</strong> (in memory and on disk), and <strong>Zombie</strong> states - from <a href="https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf">Redhat</a></p>

<p><img src="/assets/img/process-state.webp" alt="" title="Process state life cycle" /></p>

<h4 id="41-runable-state">4.1 Runable state</h4>
<p>When a process is in a Runnable state, it means it has all the resources it needs to run, except that the CPU
is not available.</p>

<p>For example: A process is dealing with I/O, so it does not immediately need the CPU,  when the process finishes the I/O operation, a signal is generated to the CPU and the scheduler keeps that process in the run queue (the list of ready-to-run processes maintained by the kernel) - <strong>Runable</strong>. When the CPU is available, this process will enter into <strong>Running</strong> state</p>

<h4 id="42-running-state">4.2 Running state</h4>
<p>The process that is executing and using the CPU at a particular moment is called a <strong>Running</strong> process.</p>

<p>A CPU can execute either in kernel mode (sy) or in user mode (us). When a user initiates a process, the process starts working in user mode. That user mode process does not have access to kernel data structures or algorithms. Each CPU type provides special instructions to switch from user mode to kernel mode - they‚Äôre <strong>system calls</strong></p>

<p><strong>System calls</strong>: communication chanel between user space program and kernel</p>

<h4 id="43-sleeping-state">4.3 Sleeping state</h4>
<p>A process enters a <strong>Sleeping</strong> state when it needs resources that are not currently available. At that point, it either goes voluntarily into Sleep state or the kernel puts it into Sleep state. Going into Sleep state means the process immediately gives up its access to the CPU.</p>

<p>When the resource the process is waiting on becomes available, a signal is sent to the CPU. The next time the scheduler gets a chance to schedule this sleeping process, the scheduler will put the process either in Running or Runnable state</p>

<h4 id="44-terminatedstopped-state">4.4 Terminated/Stopped state</h4>
<p>Processes can end when they call the exit system themselves or receive signals to end. We use <code class="highlighter-rouge">kill -9 &lt;PID&gt;</code> to kill a process.</p>

<p>See more at <a href="https://github.com/hieuhtr/Blog/blob/master/2017/Signal-of-Linux.md">Signals</a></p>

<h4 id="45-zombie-state">4.5 Zombie state</h4>
<p>When a process dies on Linux, it isn‚Äôt all removed from memory immediately ‚Äî its process descriptor stays in memory (the process descriptor only takes a tiny amount of memory). The process‚Äôs status becomes <code class="highlighter-rouge">EXIT_ZOMBIE</code> and the process‚Äôs parent is notified that its child process has died with the <code class="highlighter-rouge">SIGCHLD</code> signal. The parent process is then supposed to execute the <code class="highlighter-rouge">wait()</code> system call to read the dead process‚Äôs exit status and other information. This allows the parent process to get information from the dead process. After <code class="highlighter-rouge">wait()</code> is called, the zombie process is completely removed from memory.</p>

<p>This normally happens very quickly, so you won‚Äôt see zombie processes accumulating on your system. However, if a parent process isn‚Äôt programmed properly and never calls wait(), its zombie children will stick around in memory until they‚Äôre cleaned up. - from <a href="https://www.howtogeek.com/119815/htg-explains-what-is-a-zombie-process-on-linux/">here</a></p>

<p>Zombies that exist for more than a short period of time typically indicate a bug in the parent program, or just an uncommon decision to not reap children (see example). If the parent program is no longer running, zombie processes typically indicate a bug in the operating system. - from <a href="https://en.wikipedia.org/wiki/Zombie_process">Wiki</a></p>

<hr />

<p>Here are the different values that the s, stat and state output specifiers (header ‚ÄúSTAT‚Äù or ‚ÄúS‚Äù) will display to describe the state of a process:</p>

<ul>
  <li>D:    uninterruptible sleep (usually IO)</li>
  <li>R:    running or runnable (on run queue)</li>
  <li>S:    interruptible sleep (waiting for an event to complete)</li>
  <li>T:    stopped by job control signal</li>
  <li>t:    stopped by debugger during the tracing</li>
  <li>W:    paging (not valid since the 2.6.xx kernel)</li>
  <li>X:    dead (should never be seen)</li>
  <li>Z:    defunct (‚Äúzombie‚Äù) process, terminated but not reaped by its parent</li>
</ul>

<p>See state of all processes by using <code class="highlighter-rouge">ps -el</code> command.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>‚ùØ‚ùØ ps -el
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0     1     0  0  80   0 - 29910 -      ?        00:00:04 systemd
1 S     0     2     0  0  80   0 -     0 -      ?        00:00:00 kthreadd
1 S     0     4     2  0  60 -20 -     0 -      ?        00:00:00 kworker/0:0H
...
</code></pre>
</div>

<p>Something more:</p>
<ul>
  <li>Understanding Linux Process States- See <a href="https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf">document from RedHat</a></li>
  <li>Signals- See <a href="https://github.com/hieuhtr/Blog/blob/master/2017/Signal-of-Linux.md">Signals of Linux</a></li>
  <li>Zombie process - See <a href="https://en.wikipedia.org/wiki/Zombie_process">Wiki</a></li>
</ul>

<h3 id="5-cpu-organization-and-operation">5. CPU organization and operation</h3>

    <div id="gitment-container"></div>
  </div>

  <footer class="article-footer">

  <hr/>

  <section class="author">
  <div class="authorimage box" style="background: url(/assets/img/avatar.webp)"></div>
  <div class="authorinfo box">
    <p class="bio" style="color: #222">
      I'm an engineer who likes learning, discussing, and solving problems. These days, I'm focusing on DevOps because I'd love to help ensure that services stay up and running, while continuing to ship software to customers rapidly. I also have a passion for building robust infrastructure at world scale.
    </p>
    <a class="github-button" href="https://github.com/hieuhtr" data-size="large" data-show-count="true" aria-label="Follow @hieuhtr on GitHub">Follow @hieuhtr</a>
  </div>
</section>


  </footer>

</article>

          </div>
        </div>
      </div>
    </div>
  </body>
</html>
